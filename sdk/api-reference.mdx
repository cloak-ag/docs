---
title: "API reference"
description: "Complete SDK method and type documentation"
icon: "code"
---

This reference documents all public methods, types, and utilities exported by `@cloak.ag/sdk`.

## CloakSDK

The main client for interacting with the Cloak protocol.

### Constructor

```typescript
new CloakSDK(config: CloakSDKConfig)
```

<ParamField body="keypairBytes" type="Uint8Array">
Keypair secret key for signing transactions. Required for Node.js usage.
</ParamField>

<ParamField body="wallet" type="WalletAdapter">
Wallet adapter for browser environments. Provides `publicKey`, `signTransaction`, and `sendTransaction`.
</ParamField>

<ParamField body="network" type="Network" default="devnet">
Target network: `"devnet"` | `"mainnet"` | `"localnet"` | `"testnet"`
</ParamField>

<ParamField body="cloakKeys" type="CloakKeyPair">
Optional key hierarchy for v2.0 features (note scanning, encrypted outputs).
</ParamField>

<ParamField body="programId" type="PublicKey">
Custom program ID. Defaults to the official Cloak program.
</ParamField>

<ParamField body="relayUrl" type="string">
Custom relay URL. Defaults to `https://api.cloak.ag`.
</ParamField>

<ParamField body="debug" type="boolean" default="false">
Enable structured debug logging.
</ParamField>

<CodeGroup>
```typescript Node.js
import { CloakSDK } from "@cloak.ag/sdk";
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.fromSecretKey(secretKey);

const sdk = new CloakSDK({
  keypairBytes: keypair.secretKey,
  network: "devnet",
  debug: true,
});
```

```typescript React/Browser
import { CloakSDK } from "@cloak.ag/sdk";
import { useWallet } from "@solana/wallet-adapter-react";

const { publicKey, signTransaction, sendTransaction } = useWallet();

const sdk = new CloakSDK({
  wallet: { publicKey, signTransaction, sendTransaction },
  network: "devnet",
});
```
</CodeGroup>

---

### deposit

Deposit SOL into the privacy pool.

```typescript
async deposit(
  connection: Connection,
  amountOrNote: number | CloakNote,
  options?: DepositOptions
): Promise<DepositResult>
```

<ParamField body="connection" type="Connection" required>
Solana RPC connection.
</ParamField>

<ParamField body="amountOrNote" type="number | CloakNote" required>
Amount in lamports, or an existing note to deposit.
</ParamField>

<ParamField body="options" type="DepositOptions">
Optional configuration.

<Expandable title="DepositOptions">
  <ParamField body="onProgress" type="function">
  Callback for progress updates: `(status: DepositStatus) => void`
  </ParamField>
  
  <ParamField body="onNoteGenerated" type="function">
  **Critical callback** fired before deposit. Use to persist the note.
  `(note: CloakNote) => Promise<void>`
  </ParamField>
  
  <ParamField body="skipPreflight" type="boolean" default="false">
  Skip transaction simulation.
  </ParamField>
  
  <ParamField body="computeUnits" type="number" default="40000">
  Compute unit limit for the transaction.
  </ParamField>
  
  <ParamField body="priorityFee" type="number" default="10000">
  Priority fee in micro-lamports.
  </ParamField>
  
  <ParamField body="optimizeCU" type="boolean" default="false">
  Enable simulation-based compute unit optimization. Only works in keypair mode (Node.js), ignored in wallet/browser mode.
  </ParamField>
  
  <ParamField body="loadedAccountsDataSizeLimit" type="number" default="262144">
  Loaded accounts data size limit in bytes. Default 256KB. Set to 0 to disable.
  </ParamField>
</Expandable>
</ParamField>

<ResponseField name="DepositResult" type="object">
<Expandable title="Properties">
  <ResponseField name="note" type="CloakNote" required>
  The note with deposit metadata. **Save this immediately.**
  </ResponseField>
  
  <ResponseField name="signature" type="string" required>
  Transaction signature.
  </ResponseField>
  
  <ResponseField name="leafIndex" type="number" required>
  Index in the Merkle tree.
  </ResponseField>
  
  <ResponseField name="root" type="string" required>
  Merkle root after deposit.
  </ResponseField>
</Expandable>
</ResponseField>

```typescript
const result = await sdk.deposit(connection, 100_000_000, {
  onNoteGenerated: async (note) => {
    await localStorage.setItem(`note_${note.commitment}`, JSON.stringify(note));
  },
  onProgress: (status) => console.log("Deposit:", status),
});

console.log("Deposited at leaf", result.leafIndex);
```

---

### withdraw

Withdraw to a single recipient.

```typescript
async withdraw(
  connection: Connection,
  note: CloakNote,
  recipient: PublicKey,
  options?: WithdrawOptions
): Promise<TransferResult>
```

<ParamField body="connection" type="Connection" required>
Solana RPC connection.
</ParamField>

<ParamField body="note" type="CloakNote" required>
Note to spend. Must be deposited (have `leafIndex`).
</ParamField>

<ParamField body="recipient" type="PublicKey" required>
Recipient's Solana address.
</ParamField>

<ParamField body="options" type="WithdrawOptions">
<Expandable title="Properties">
  <ParamField body="withdrawAll" type="boolean" default="true">
  Withdraw full amount minus fees.
  </ParamField>
  
  <ParamField body="amount" type="number">
  Specific amount to withdraw (if not withdrawing all).
  </ParamField>
  
  <ParamField body="onProgress" type="function">
  Progress callback: `(status: string) => void`
  </ParamField>
</Expandable>
</ParamField>

<ResponseField name="TransferResult" type="object">
<Expandable title="Properties">
  <ResponseField name="signature" type="string" required>
  Transaction signature.
  </ResponseField>
  
  <ResponseField name="outputs" type="array" required>
  Array of `{ recipient: string, amount: number }`.
  </ResponseField>
  
  <ResponseField name="nullifier" type="string" required>
  Nullifier used (prevents double-spend).
  </ResponseField>
  
  <ResponseField name="root" type="string" required>
  Merkle root proven against.
  </ResponseField>
</Expandable>
</ResponseField>

```typescript
const result = await sdk.withdraw(connection, note, recipient, {
  withdrawAll: true,
  onProgress: (status) => console.log("Withdraw:", status),
});

console.log("Sent", result.outputs[0].amount, "to", result.outputs[0].recipient);
```

---

### send

Send to multiple recipients (1-5).

```typescript
async send(
  connection: Connection,
  note: CloakNote,
  recipients: Transfer[],
  options?: TransferOptions
): Promise<TransferResult>
```

<ParamField body="recipients" type="Transfer[]" required>
Array of 1-5 recipients with amounts. Sum must equal `getDistributableAmount(note.amount)`.

```typescript
interface Transfer {
  recipient: PublicKey;
  amount: number; // lamports
}
```
</ParamField>

```typescript
import { getDistributableAmount } from "@cloak.ag/sdk";

const distributable = getDistributableAmount(note.amount);

const result = await sdk.send(connection, note, [
  { recipient: address1, amount: Math.floor(distributable * 0.5) },
  { recipient: address2, amount: Math.floor(distributable * 0.5) },
]);
```

---

### swap

Swap SOL for SPL tokens privately.

```typescript
async swap(
  connection: Connection,
  note: CloakNote,
  recipient: PublicKey,
  options: SwapOptions
): Promise<SwapResult>
```

<ParamField body="options" type="SwapOptions" required>
<Expandable title="Properties">
  <ParamField body="outputMint" type="string" required>
  SPL token mint address to swap to.
  </ParamField>
  
  <ParamField body="slippageBps" type="number" default="100">
  Slippage tolerance in basis points (100 = 1%).
  </ParamField>
  
  <ParamField body="minOutputAmount" type="number">
  Minimum tokens to receive. Required if `getQuote` not provided.
  </ParamField>
  
  <ParamField body="getQuote" type="function">
  Optional quote fetcher: `(amount, mint, slippage) => Promise<{ outAmount, minOutputAmount }>`
  </ParamField>
  
  <ParamField body="recipientAta" type="string">
  Pre-computed associated token account. Recommended for browser usage.
  </ParamField>
</Expandable>
</ParamField>

<ResponseField name="SwapResult" type="object">
Extends `TransferResult` with:

<Expandable title="Additional properties">
  <ResponseField name="outputMint" type="string" required>
  Token mint received.
  </ResponseField>
  
  <ResponseField name="minOutputAmount" type="number" required>
  Minimum guaranteed output.
  </ResponseField>
  
  <ResponseField name="actualOutputAmount" type="number">
  Actual tokens received (may exceed minimum).
  </ResponseField>
</Expandable>
</ResponseField>

```typescript
const USDC = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

const result = await sdk.swap(connection, note, recipient, {
  outputMint: USDC,
  slippageBps: 100, // 1%
  minOutputAmount: 1_000_000, // 1 USDC
});
```

---

### generateNote

Generate a new note without depositing.

```typescript
async generateNote(
  amountLamports: number,
  useWalletKeys?: boolean
): Promise<CloakNote>
```

```typescript
const note = await sdk.generateNote(100_000_000);
// Later: await sdk.deposit(connection, note);
```

---

### getMerkleProof

Get Merkle proof for a leaf index directly from on-chain state.

```typescript
async getMerkleProof(
  connection: Connection,
  leafIndex: number
): Promise<MerkleProof>
```

```typescript
const proof = await sdk.getMerkleProof(connection, note.leafIndex);
console.log("Root:", proof.root);
console.log("Path elements:", proof.pathElements.length);
```

<Info>
The SDK computes Merkle proofs directly from on-chain state without requiring an indexer service. This improves reliability and reduces external dependencies.
</Info>

---

### getCurrentRoot

Get the current Merkle root directly from on-chain state.

```typescript
async getCurrentRoot(connection: Connection): Promise<string>
```

```typescript
const root = await sdk.getCurrentRoot(connection);
console.log("Current root:", root);
```

---

## Utility functions

### Fee calculations

```typescript
import {
  calculateFee,
  getDistributableAmount,
  FIXED_FEE_LAMPORTS,    // 5_000_000 (0.005 SOL)
  VARIABLE_FEE_RATE,     // 0.003 (0.3%)
  LAMPORTS_PER_SOL,      // 1_000_000_000
} from "@cloak.ag/sdk";

// Calculate total fee
const fee = calculateFee(100_000_000); // Returns 5_300_000 (fixed + 0.3%)

// Get amount after fees
const distributable = getDistributableAmount(100_000_000); // ~94_700_000
```

### Crypto utilities

```typescript
import {
  computeCommitment,
  computeNullifierAsync,
  computeOutputsHashAsync,
  poseidonHash,
  hexToBytes,
  bytesToHex,
  randomBytes,
} from "@cloak.ag/sdk";

// Compute Poseidon commitment
const commitment = await computeCommitment(amount, r, sk_spend);

// Compute nullifier
const nullifier = await computeNullifierAsync(sk_spend_hex, leafIndex);
```

### Validation utilities

```typescript
import {
  isValidSolanaAddress,
  validateNote,
  validateWithdrawableNote,
  validateTransfers,
} from "@cloak.ag/sdk";

// Validate address
if (!isValidSolanaAddress(address)) {
  throw new Error("Invalid address");
}

// Validate note structure
validateNote(note); // Throws if invalid

// Validate note is ready for withdrawal
validateWithdrawableNote(note); // Throws if not deposited
```

### Network utilities

```typescript
import {
  detectNetworkFromRpcUrl,
  getRpcUrlForNetwork,
  getExplorerUrl,
  getAddressExplorerUrl,
} from "@cloak.ag/sdk";

const network = detectNetworkFromRpcUrl("https://api.devnet.solana.com");
// Returns: "devnet"

const explorerUrl = getExplorerUrl(signature, "devnet");
// Returns: "https://explorer.solana.com/tx/..."
```

### Key management

```typescript
import {
  generateCloakKeys,
  generateMasterSeed,
  deriveSpendKey,
  deriveViewKey,
  exportKeys,
  importKeys,
} from "@cloak.ag/sdk";

// Generate full key hierarchy
const keys = generateCloakKeys();

// Export for backup
const backup = exportKeys(keys);

// Import from backup
const restored = importKeys(backup);
```

### Error utilities

```typescript
import {
  ShieldPoolErrors,
  parseError,
  parseTransactionError,
  createCloakError,
  RootNotFoundError,
  isRootNotFoundError,
  type UserFriendlyError,
  type ErrorCategory,
} from "@cloak.ag/sdk";

// Get user-friendly error info
const parsed: UserFriendlyError = parseError(error);
console.log(parsed.title);       // "Transaction Failed"
console.log(parsed.message);     // User-friendly description
console.log(parsed.category);    // "wallet" | "network" | "validation" | "service" | "transaction"
console.log(parsed.suggestion);  // Optional action suggestion
console.log(parsed.recoverable); // Whether user can retry

// Check for specific on-chain error codes
const errorCode = 0x1020;
console.log(ShieldPoolErrors[errorCode]); // "Double spend detected - this note has already been spent"

// Check for stale Merkle root errors
if (isRootNotFoundError(error)) {
  // Regenerate proof with fresh root
}
```

---

### On-chain proof utilities

The SDK can compute Merkle proofs directly from on-chain state without an indexer:

```typescript
import {
  computeProofFromChain,
  computeProofForLatestDeposit,
  readMerkleTreeState,
} from "@cloak.ag/sdk";

// Get proof for a specific leaf index
const proof = await computeProofFromChain(connection, merkleTreePDA, leafIndex);

// Get proof for the most recently deposited note
const latestProof = await computeProofForLatestDeposit(connection, merkleTreePDA);

// Read the full merkle tree state
const state = await readMerkleTreeState(connection, merkleTreePDA);
console.log("Current root:", state.root);
console.log("Next index:", state.nextIndex);
```

<Info>
On-chain proof computation eliminates the dependency on external indexer services, improving reliability and decentralization.
</Info>

### Pending operations utilities

Browser-based persistence for operation recovery:

```typescript
import {
  savePendingDeposit,
  loadPendingDeposits,
  updatePendingDeposit,
  removePendingDeposit,
  savePendingWithdrawal,
  loadPendingWithdrawals,
  updatePendingWithdrawal,
  removePendingWithdrawal,
  hasPendingOperations,
  getPendingOperationsSummary,
  cleanupStalePendingOperations,
  type PendingDeposit,
  type PendingWithdrawal,
} from "@cloak.ag/sdk";

// Save pending deposit before transaction
savePendingDeposit({
  note,
  startedAt: Date.now(),
  status: "pending",
});

// Check for pending operations on page load
if (hasPendingOperations()) {
  const summary = getPendingOperationsSummary();
  console.log(`${summary.deposits} pending deposits, ${summary.withdrawals} pending withdrawals`);
}

// Clean up stale operations (older than 24 hours by default)
cleanupStalePendingOperations();
```

### RelayService

Low-level relay client for advanced use cases:

```typescript
import { RelayService, type WithdrawSubmissionResult } from "@cloak.ag/sdk";

const relay = new RelayService("https://api.cloak.ag");

// Submit withdrawal with request ID callback
const signature = await relay.submitWithdraw(
  params,
  (status) => console.log("Status:", status),
  (requestId) => localStorage.setItem("pending_withdraw", requestId)
);

// Resume a pending withdrawal after page reload
const result = await relay.resumeWithdraw(requestId, onStatusUpdate);
if (result.status === "completed") {
  console.log("Completed:", result.signature);
}

// Check status manually
const status = await relay.getStatus(requestId);
```

---

## Types

### CloakNote

```typescript
interface CloakNote {
  version: string;
  amount: number;
  commitment: string;
  sk_spend: string;
  r: string;
  timestamp: number;
  network: Network;
  depositSignature?: string;
  depositSlot?: number;
  leafIndex?: number;
  root?: string;
  merkleProof?: MerkleProof;
}
```

### MerkleProof

```typescript
interface MerkleProof {
  pathElements: string[];
  pathIndices: number[];
  root?: string;
}
```

### CloakError

```typescript
class CloakError extends Error {
  category: "network" | "indexer" | "prover" | "relay" | "validation" | "wallet" | "environment";
  retryable: boolean;
  originalError?: Error;
}
```

### WalletAdapter

```typescript
interface WalletAdapter {
  publicKey: PublicKey | null;
  signTransaction?<T extends Transaction>(transaction: T): Promise<T>;
  sendTransaction?(
    transaction: Transaction,
    connection: Connection,
    options?: any
  ): Promise<string>;
}
```

### Network

```typescript
type Network = "localnet" | "devnet" | "mainnet" | "testnet";
```

