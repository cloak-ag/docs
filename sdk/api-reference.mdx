---
title: "API reference"
description: "Complete SDK method and type documentation"
icon: "code"
---

This reference documents all public methods, types, and utilities exported by `@cloak.ag/sdk`.

## CloakSDK

The main client for interacting with the Cloak protocol.

### Constructor

```typescript
new CloakSDK(config: CloakSDKConfig)
```

<ParamField body="keypairBytes" type="Uint8Array">
Keypair secret key for signing transactions. Required for Node.js usage.
</ParamField>

<ParamField body="wallet" type="WalletAdapter">
Wallet adapter for browser environments. Provides `publicKey`, `signTransaction`, and `sendTransaction`.
</ParamField>

<ParamField body="network" type="Network" default="devnet">
Target network: `"devnet"` | `"mainnet"` | `"localnet"` | `"testnet"`
</ParamField>

<ParamField body="cloakKeys" type="CloakKeyPair">
Optional key hierarchy for v2.0 features (note scanning, encrypted outputs).
</ParamField>

<ParamField body="programId" type="PublicKey">
Cloak program ID. **Required for devnet** - defaults to mainnet program.

| Network | Program ID |
|---------|------------|
| **Devnet** | `3EvH6XYQir7D2RyzCdP7QFmJFfSPfdeoB8VnpLdEF4Kr` |
| Mainnet | `c1oak6tetxYnNfvXKFkpn1d98FxtK7B68vBQLYQpWKp` |
</ParamField>

<ParamField body="relayUrl" type="string">
Custom relay URL. Defaults to `https://api.cloak.ag`.
</ParamField>

<ParamField body="debug" type="boolean" default="false">
Enable structured debug logging.
</ParamField>

<CodeGroup>
```typescript Node.js (Devnet)
import { CloakSDK } from "@cloak.ag/sdk";
import { Keypair, PublicKey } from "@solana/web3.js";

const keypair = Keypair.fromSecretKey(secretKey);
const DEVNET_PROGRAM_ID = new PublicKey("3EvH6XYQir7D2RyzCdP7QFmJFfSPfdeoB8VnpLdEF4Kr");

const sdk = new CloakSDK({
  keypairBytes: keypair.secretKey,
  network: "devnet",
  programId: DEVNET_PROGRAM_ID, // Required for devnet!
  debug: true,
});
```

```typescript React/Browser (Devnet)
import { CloakSDK } from "@cloak.ag/sdk";
import { useWallet } from "@solana/wallet-adapter-react";
import { PublicKey } from "@solana/web3.js";

const { publicKey, signTransaction, sendTransaction } = useWallet();
const DEVNET_PROGRAM_ID = new PublicKey("3EvH6XYQir7D2RyzCdP7QFmJFfSPfdeoB8VnpLdEF4Kr");

const sdk = new CloakSDK({
  wallet: { publicKey, signTransaction, sendTransaction },
  network: "devnet",
  programId: DEVNET_PROGRAM_ID, // Required for devnet!
});
```

```typescript Mainnet
import { CloakSDK } from "@cloak.ag/sdk";
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.fromSecretKey(secretKey);

// Mainnet uses default program ID
const sdk = new CloakSDK({
  keypairBytes: keypair.secretKey,
  network: "mainnet",
});
```
</CodeGroup>

---

### deposit

Deposit SOL into the privacy pool.

```typescript
async deposit(
  connection: Connection,
  amountOrNote: number | CloakNote,
  options?: DepositOptions
): Promise<DepositResult>
```

<ParamField body="connection" type="Connection" required>
Solana RPC connection.
</ParamField>

<ParamField body="amountOrNote" type="number | CloakNote" required>
Amount in lamports, or an existing note to deposit.
</ParamField>

<ParamField body="options" type="DepositOptions">
Optional configuration.

<Expandable title="DepositOptions">
  <ParamField body="onProgress" type="function">
  Callback for progress updates: `(status: DepositStatus) => void`
  </ParamField>
  
  <ParamField body="onNoteGenerated" type="function">
  **Critical callback** fired before deposit. Use to persist the note.
  `(note: CloakNote) => Promise<void>`
  </ParamField>
  
  <ParamField body="skipPreflight" type="boolean" default="false">
  Skip transaction simulation.
  </ParamField>
  
  <ParamField body="computeUnits" type="number" default="40000">
  Compute unit limit for the transaction.
  </ParamField>
  
  <ParamField body="priorityFee" type="number" default="10000">
  Priority fee in micro-lamports.
  </ParamField>
</Expandable>
</ParamField>

<ResponseField name="DepositResult" type="object">
<Expandable title="Properties">
  <ResponseField name="note" type="CloakNote" required>
  The note with deposit metadata. **Save this immediately.**
  </ResponseField>
  
  <ResponseField name="signature" type="string" required>
  Transaction signature.
  </ResponseField>
  
  <ResponseField name="leafIndex" type="number" required>
  Index in the Merkle tree.
  </ResponseField>
  
  <ResponseField name="root" type="string" required>
  Merkle root after deposit.
  </ResponseField>
</Expandable>
</ResponseField>

```typescript
const result = await sdk.deposit(connection, 100_000_000, {
  onNoteGenerated: async (note) => {
    await localStorage.setItem(`note_${note.commitment}`, JSON.stringify(note));
  },
  onProgress: (status) => console.log("Deposit:", status),
});

console.log("Deposited at leaf", result.leafIndex);
```

---

### withdraw

Withdraw to a single recipient.

```typescript
async withdraw(
  connection: Connection,
  note: CloakNote,
  recipient: PublicKey,
  options?: WithdrawOptions
): Promise<TransferResult>
```

<ParamField body="connection" type="Connection" required>
Solana RPC connection.
</ParamField>

<ParamField body="note" type="CloakNote" required>
Note to spend. Must be deposited (have `leafIndex`).
</ParamField>

<ParamField body="recipient" type="PublicKey" required>
Recipient's Solana address.
</ParamField>

<ParamField body="options" type="WithdrawOptions">
<Expandable title="Properties">
  <ParamField body="withdrawAll" type="boolean" default="true">
  Withdraw full amount minus fees.
  </ParamField>
  
  <ParamField body="amount" type="number">
  Specific amount to withdraw (if not withdrawing all).
  </ParamField>
  
  <ParamField body="onProgress" type="function">
  Progress callback: `(status: string) => void`
  </ParamField>
</Expandable>
</ParamField>

<ResponseField name="TransferResult" type="object">
<Expandable title="Properties">
  <ResponseField name="signature" type="string" required>
  Transaction signature.
  </ResponseField>
  
  <ResponseField name="outputs" type="array" required>
  Array of `{ recipient: string, amount: number }`.
  </ResponseField>
  
  <ResponseField name="nullifier" type="string" required>
  Nullifier used (prevents double-spend).
  </ResponseField>
  
  <ResponseField name="root" type="string" required>
  Merkle root proven against.
  </ResponseField>
</Expandable>
</ResponseField>

```typescript
const result = await sdk.withdraw(connection, note, recipient, {
  withdrawAll: true,
  onProgress: (status) => console.log("Withdraw:", status),
});

console.log("Sent", result.outputs[0].amount, "to", result.outputs[0].recipient);
```

---

### send

Send to multiple recipients (1-5).

```typescript
async send(
  connection: Connection,
  note: CloakNote,
  recipients: Transfer[],
  options?: TransferOptions
): Promise<TransferResult>
```

<ParamField body="recipients" type="Transfer[]" required>
Array of 1-5 recipients with amounts. Sum must equal `getDistributableAmount(note.amount)`.

```typescript
interface Transfer {
  recipient: PublicKey;
  amount: number; // lamports
}
```
</ParamField>

```typescript
import { getDistributableAmount } from "@cloak.ag/sdk";

const distributable = getDistributableAmount(note.amount);

const result = await sdk.send(connection, note, [
  { recipient: address1, amount: Math.floor(distributable * 0.5) },
  { recipient: address2, amount: Math.floor(distributable * 0.5) },
]);
```

---

### swap

Swap SOL for SPL tokens privately.

```typescript
async swap(
  connection: Connection,
  note: CloakNote,
  recipient: PublicKey,
  options: SwapOptions
): Promise<SwapResult>
```

<ParamField body="options" type="SwapOptions" required>
<Expandable title="Properties">
  <ParamField body="outputMint" type="string" required>
  SPL token mint address to swap to.
  </ParamField>
  
  <ParamField body="slippageBps" type="number" default="100">
  Slippage tolerance in basis points (100 = 1%).
  </ParamField>
  
  <ParamField body="minOutputAmount" type="number">
  Minimum tokens to receive. Required if `getQuote` not provided.
  </ParamField>
  
  <ParamField body="getQuote" type="function">
  Optional quote fetcher: `(amount, mint, slippage) => Promise<{ outAmount, minOutputAmount }>`
  </ParamField>
  
  <ParamField body="recipientAta" type="string">
  Pre-computed associated token account. Recommended for browser usage.
  </ParamField>
</Expandable>
</ParamField>

<ResponseField name="SwapResult" type="object">
Extends `TransferResult` with:

<Expandable title="Additional properties">
  <ResponseField name="outputMint" type="string" required>
  Token mint received.
  </ResponseField>
  
  <ResponseField name="minOutputAmount" type="number" required>
  Minimum guaranteed output.
  </ResponseField>
  
  <ResponseField name="actualOutputAmount" type="number">
  Actual tokens received (may exceed minimum).
  </ResponseField>
</Expandable>
</ResponseField>

```typescript
const USDC = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

const result = await sdk.swap(connection, note, recipient, {
  outputMint: USDC,
  slippageBps: 100, // 1%
  minOutputAmount: 1_000_000, // 1 USDC
});
```

---

### generateNote

Generate a new note without depositing.

```typescript
async generateNote(
  amountLamports: number,
  useWalletKeys?: boolean
): Promise<CloakNote>
```

```typescript
const note = await sdk.generateNote(100_000_000);
// Later: await sdk.deposit(connection, note);
```

---

### getMerkleProof

Get Merkle proof for a leaf index directly from on-chain state.

```typescript
async getMerkleProof(
  connection: Connection,
  leafIndex: number
): Promise<MerkleProof>
```

<ParamField body="connection" type="Connection" required>
Solana RPC connection.
</ParamField>

<ParamField body="leafIndex" type="number" required>
Leaf index in the Merkle tree.
</ParamField>

```typescript
const proof = await sdk.getMerkleProof(connection, note.leafIndex);
console.log("Root:", proof.root);
console.log("Path elements:", proof.pathElements.length);
```

---

### getCurrentRoot

Get the current Merkle root directly from on-chain state.

```typescript
async getCurrentRoot(connection: Connection): Promise<string>
```

```typescript
const root = await sdk.getCurrentRoot(connection);
console.log("Current root:", root);
```

---

### loadNotes

Load all notes from the SDK's internal storage.

```typescript
async loadNotes(): Promise<CloakNote[]>
```

```typescript
const notes = await sdk.loadNotes();
console.log(`Found ${notes.length} saved notes`);
```

---

### saveNote

Save a note to the SDK's internal storage.

```typescript
async saveNote(note: CloakNote): Promise<void>
```

```typescript
await sdk.saveNote(depositResult.note);
```

---

## Utility functions

### Fee calculations

```typescript
import {
  calculateFee,
  getDistributableAmount,
  FIXED_FEE_LAMPORTS,    // 3_000_000
  VARIABLE_FEE_RATE,     // 0.005
  LAMPORTS_PER_SOL,      // 1_000_000_000
} from "@cloak.ag/sdk";

// Calculate total fee
const fee = calculateFee(100_000_000); // Returns fee in lamports

// Get amount after fees
const distributable = getDistributableAmount(100_000_000);
```

### Crypto utilities

```typescript
import {
  computeCommitment,
  computeNullifierAsync,
  computeOutputsHashAsync,
  poseidonHash,
  hexToBytes,
  bytesToHex,
  randomBytes,
} from "@cloak.ag/sdk";

// Compute Poseidon commitment
const commitment = await computeCommitment(amount, r, sk_spend);

// Compute nullifier
const nullifier = await computeNullifierAsync(sk_spend_hex, leafIndex);
```

### Validation utilities

```typescript
import {
  isValidSolanaAddress,
  validateNote,
  validateWithdrawableNote,
  validateTransfers,
} from "@cloak.ag/sdk";

// Validate address
if (!isValidSolanaAddress(address)) {
  throw new Error("Invalid address");
}

// Validate note structure
validateNote(note); // Throws if invalid

// Validate note is ready for withdrawal
validateWithdrawableNote(note); // Throws if not deposited
```

### Network utilities

```typescript
import {
  detectNetworkFromRpcUrl,
  getRpcUrlForNetwork,
  getExplorerUrl,
  getAddressExplorerUrl,
} from "@cloak.ag/sdk";

const network = detectNetworkFromRpcUrl("https://api.devnet.solana.com");
// Returns: "devnet"

const explorerUrl = getExplorerUrl(signature, "devnet");
// Returns: "https://explorer.solana.com/tx/..."
```

### Key management

```typescript
import {
  generateCloakKeys,
  generateMasterSeed,
  deriveSpendKey,
  deriveViewKey,
  exportKeys,
  importKeys,
} from "@cloak.ag/sdk";

// Generate full key hierarchy
const keys = generateCloakKeys();

// Export for backup
const backup = exportKeys(keys);

// Import from backup
const restored = importKeys(backup);
```

### On-chain proof utilities

The SDK computes Merkle proofs directly from on-chain state, eliminating the need for an external indexer.

```typescript
import {
  computeProofFromChain,
  readMerkleTreeState,
} from "@cloak.ag/sdk";

// Compute a Merkle proof for a specific leaf
const proof = await computeProofFromChain(connection, merkleTreePDA, leafIndex);
console.log("Root:", proof.root);
console.log("Path elements:", proof.pathElements);

// Read the full Merkle tree state
const state = await readMerkleTreeState(connection, merkleTreePDA);
console.log("Current root:", state.root);
console.log("Next index:", state.nextIndex);
```

### Logging utilities

Enable structured debug logging for troubleshooting.

```typescript
import {
  createLogger,
  setDebugMode,
  withTiming,
  formatSol,
  truncate,
} from "@cloak.ag/sdk";

// Enable debug mode globally
setDebugMode(true);

// Create a module-specific logger
const log = createLogger("my-app::deposits");
log.info("Processing deposit", { amount: formatSol(100_000_000) });

// Time an operation
const { result, durationMs } = await withTiming(log, "deposit", async () => {
  return sdk.deposit(connection, amount);
});
log.info("Completed", { duration_ms: durationMs });

// Truncate long strings for display
console.log(truncate(signature)); // "5Kn4..."
```

---

## Types

### CloakNote

```typescript
interface CloakNote {
  version: string;
  amount: number;
  commitment: string;
  sk_spend: string;
  r: string;
  timestamp: number;
  network: Network;
  depositSignature?: string;
  depositSlot?: number;
  leafIndex?: number;
  root?: string;
  merkleProof?: MerkleProof;
}
```

### MerkleProof

```typescript
interface MerkleProof {
  pathElements: string[];
  pathIndices: number[];
  root?: string;
}
```

### CloakError

```typescript
class CloakError extends Error {
  category: "network" | "prover" | "relay" | "validation" | "wallet" | "environment";
  retryable: boolean;
  originalError?: Error;
}
```

<Note>
The `indexer` category still exists for backward compatibility but is rarely used since proofs are now computed directly from on-chain state.
</Note>

### WalletAdapter

```typescript
interface WalletAdapter {
  publicKey: PublicKey | null;
  signTransaction?<T extends Transaction>(transaction: T): Promise<T>;
  sendTransaction?(
    transaction: Transaction,
    connection: Connection,
    options?: any
  ): Promise<string>;
}
```

### Network

```typescript
type Network = "localnet" | "devnet" | "mainnet" | "testnet";
```

