---
title: "Core concepts"
description: "Protocol primitives used by both note-based and UTXO-based SDK flows"
icon: "lightbulb"
---

## Two transaction interfaces

Cloak SDK v2 supports:

- **Note model** (`CloakSDK`) for app-oriented deposit/withdraw UX
- **UTXO model** (`transact` and helpers) for explicit state control

Both rely on the same proof system and on-chain state.

## Commitments and Merkle tree

Each deposit/output creates a Poseidon commitment and appends it to the on-chain Merkle tree.

- Height: `32`
- Root history: `100` recent roots

Proof generation needs:

- Leaf index
- Path elements/indices
- A root still present in root history

## Nullifiers

Spending creates a nullifier. The program rejects a reused nullifier.

This is the core double-spend guard for both note and UTXO flows.

## Stale-root retries

If your proof root is no longer in history, transactions can fail with `RootNotFound` (`0x1001`).

The SDK includes retry paths that:

- fetch fresh Merkle data
- regenerate proof
- resubmit

## Fee model

Shared constants:

- Fixed fee: `5_000_000` lamports
- Variable fee: `amount * 3 / 1000`
- Minimum deposit: `10_000_000` lamports

## Proof data shapes

- Note-based withdraw requests use 104-byte public input fields at relay boundary.
- UTXO transact requests use 232-byte public input blobs (`root + publicAmount + extDataHash + mint + nullifiers + commitments`).

## Related pages

- UTXO details: [UTXO Transactions (v2)](/sdk/utxo-transactions)
- Program internals: [Shield Pool Program](/protocol/shield-pool)
- Relay routes: [Relay API](/services/relay-api)
