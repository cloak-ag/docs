---
title: "Error handling"
description: "Handle errors gracefully and implement recovery strategies"
icon: "triangle-exclamation"
---

The Cloak SDK provides structured error handling with categorized errors, retry hints, and recovery utilities. This guide covers common error scenarios and how to handle them.

## CloakError

All SDK errors extend the `CloakError` class with useful metadata:

```typescript
class CloakError extends Error {
  category: ErrorCategory;
  retryable: boolean;
  originalError?: Error;
}

type ErrorCategory = 
  | "network"      // RPC or network failures
  | "prover"       // Proof generation failures
  | "relay"        // Relay service errors
  | "validation"   // Invalid inputs
  | "wallet"       // Wallet connection or signing issues
  | "environment"; // Missing dependencies or configuration
```

## Shield Pool error codes

The on-chain program uses hex error codes. The SDK provides `ShieldPoolErrors` to map these to user-friendly messages:

```typescript
import { ShieldPoolErrors } from "@cloak.ag/sdk";

// Check for specific error codes
const message = ShieldPoolErrors[0x1001]; // "Root not found in the roots ring"
```

### Error code reference

| Code | Name | Description |
|------|------|-------------|
| `0x1000` | InvalidRoot | Invalid Merkle root |
| `0x1001` | RootNotFound | Root not found in the roots ring (stale proof) |
| `0x1002` | RootsRingFull | Roots ring is full |
| `0x1010` | ProofInvalid | Zero-knowledge proof is invalid |
| `0x1011` | InvalidProofSize | Invalid proof size (expected 260 bytes) |
| `0x1012` | InvalidPublicInputs | Invalid public inputs |
| `0x1013` | VKeyMismatch | Verification key mismatch |
| `0x1020` | DoubleSpend | Note has already been spent |
| `0x1021` | NullifierShardFull | Nullifier shard is full (deprecated) |
| `0x1022` | InvalidNullifier | Invalid nullifier |
| `0x1023` | NullifierAlreadyUsed | Nullifier already used |
| `0x1030` | OutputsMismatch | Output addresses or amounts don't match proof |
| `0x1031` | Conservation | Amount conservation failed |
| `0x1032` | InvalidOutputsHash | Invalid outputs hash |
| `0x1033` | InvalidAmount | Invalid amount |
| `0x1034` | InvalidRecipient | Invalid recipient address |
| `0x1035` | CommitmentAlreadyExists | Commitment already in tree |
| `0x1050` | BadAccounts | Account validation failed |
| `0x1058` | InsufficientLamports | Insufficient lamports in pool |
| `0x1076` | ProofVerificationFailed | Groth16 proof verification failed |
| `0x1080` | MerkleTreeFull | Merkle tree is full |

### Common error handling

```typescript
import { ShieldPoolErrors, isRootNotFoundError } from "@cloak.ag/sdk";

try {
  await sdk.withdraw(connection, note, recipient);
} catch (error) {
  // Check for stale root (needs proof refresh)
  if (isRootNotFoundError(error)) {
    console.log("Merkle root expired, SDK will retry with fresh proof");
    // The SDK handles this internally with up to 3 retries
  }
  
  // Parse hex error code from transaction
  const match = error.message?.match(/0x([0-9a-f]{4})/i);
  if (match) {
    const code = parseInt(match[1], 16);
    const message = ShieldPoolErrors[code];
    console.log(`Program error: ${message || 'Unknown'} (0x${code.toString(16)})`);
  }
}
```

## Common issues and solutions

### 0x1001 RootNotFound on Devnet

**Problem**: Withdrawal fails with `custom program error: 0x1001` (RootNotFound).

**Cause**: The SDK defaults to mainnet's program ID. On devnet, this causes wrong Merkle tree PDAs to be derived.

**Solution**: Explicitly set the devnet program ID:

```typescript
import { PublicKey } from "@solana/web3.js";

const DEVNET_PROGRAM_ID = new PublicKey("3EvH6XYQir7D2RyzCdP7QFmJFfSPfdeoB8VnpLdEF4Kr");

const sdk = new CloakSDK({
  keypairBytes: keypair.secretKey,
  network: "devnet",
  programId: DEVNET_PROGRAM_ID,  // This is required!
});
```

### "max loaded accounts data size cap" error

**Problem**: Deposit fails with account data size exceeded error on devnet.

**Cause**: Public devnet RPC has stricter limits than mainnet.

**Solution**: Use a dedicated RPC (like Helius) or set `loadedAccountsDataSizeLimit`:

```typescript
await sdk.deposit(connection, amount, {
  loadedAccountsDataSizeLimit: 512 * 1024, // 512KB
});
```

### Stale Merkle root after many deposits

**Problem**: Withdrawal fails with 0x1001 after waiting too long.

**Cause**: The on-chain roots ring only stores the last 100 roots. If >100 deposits happen between your deposit and withdrawal, your proof's root expires.

**Solution**: The SDK automatically retries with fresh proofs (up to 3 times). If it still fails, re-deposit.

## Handling errors by category

### Network errors

Network errors are usually transient and retryable:

```typescript
import { CloakError } from "@cloak.ag/sdk";

try {
  await sdk.deposit(connection, amount);
} catch (error) {
  if (error instanceof CloakError && error.category === "network") {
    if (error.retryable) {
      console.log("Network error, retrying in 2 seconds...");
      await delay(2000);
      // Retry the operation
    } else {
      console.error("Network configuration error:", error.message);
    }
  }
}
```

<AccordionGroup>
<Accordion title="Common network errors">

| Error | Cause | Solution |
|-------|-------|----------|
| `timeout` | RPC unresponsive | Retry with backoff, or switch RPC |
| `rate limited` | Too many requests | Implement exponential backoff |
| `connection refused` | RPC down | Switch to backup RPC |

</Accordion>
</AccordionGroup>

### Wallet errors

Wallet errors occur when signing is rejected or the wallet disconnects:

```typescript
try {
  await sdk.deposit(connection, amount);
} catch (error) {
  if (error instanceof CloakError && error.category === "wallet") {
    if (error.message.includes("not connected")) {
      showMessage("Please connect your wallet");
      openWalletModal();
    } else if (error.message.includes("rejected")) {
      showMessage("Transaction cancelled");
    } else if (error.message.includes("insufficient")) {
      showMessage("Insufficient SOL balance");
    }
  }
}
```

### Prover errors

Proof generation can fail due to circuit issues or resource constraints:

```typescript
try {
  await sdk.withdraw(connection, note, recipient);
} catch (error) {
  if (error instanceof CloakError && error.category === "prover") {
    if (error.message.includes("Circuit")) {
      showMessage("Failed to load proof circuits. Please refresh.");
    } else if (error.retryable) {
      showMessage("Proof generation failed. Retrying...");
      // Retry once
    } else {
      showMessage("Unable to generate proof. Please try again later.");
    }
  }
}
```

<Tip>
Proof generation is computationally intensive. On slower devices, consider showing a loading indicator with an estimated time.
</Tip>

### Relay errors

Relay errors occur when submitting withdrawals:

```typescript
try {
  await sdk.withdraw(connection, note, recipient);
} catch (error) {
  if (error instanceof CloakError && error.category === "relay") {
    if (error.message.includes("RootNotFound")) {
      // The SDK handles this internally with retries,
      // but you might see it after max retries
      showMessage("Merkle tree updated. Please try again.");
    } else if (error.message.includes("nullifier")) {
      showMessage("This note has already been spent.");
      removeNoteFromStorage(note);
    } else if (error.retryable) {
      showMessage("Relay temporarily unavailable. Retrying...");
    }
  }
}
```

### Validation errors

Validation errors indicate incorrect inputs:

```typescript
try {
  await sdk.send(connection, note, recipients);
} catch (error) {
  if (error instanceof CloakError && error.category === "validation") {
    if (error.message.includes("sum")) {
      showMessage("Recipient amounts don't match note balance");
    } else if (error.message.includes("deposited")) {
      showMessage("Note must be deposited before withdrawal");
    } else if (error.message.includes("address")) {
      showMessage("Invalid recipient address");
    }
  }
}
```

### On-chain errors

Errors reading on-chain Merkle tree state:

```typescript
try {
  await sdk.deposit(connection, amount);
} catch (error) {
  if (error instanceof CloakError && error.category === "network") {
    if (error.message.includes("Merkle tree")) {
      // Failed to read on-chain state
      showMessage("Failed to read blockchain state. Please try again.");
    } else if (error.retryable) {
      showMessage("Network issue. Retrying...");
    }
  }
}
```

<Tip>
The SDK computes Merkle proofs directly from on-chain state, making it more reliable than external indexer services.
</Tip>

## Comprehensive error handler

Here's a reusable error handler for all SDK operations:

```typescript utils/handleCloakError.ts
import { CloakError } from "@cloak.ag/sdk";

interface ErrorHandlerOptions {
  onRetry?: () => Promise<void>;
  showMessage: (message: string) => void;
  logError?: (error: unknown) => void;
}

export async function handleCloakError(
  error: unknown,
  options: ErrorHandlerOptions
): Promise<boolean> {
  const { onRetry, showMessage, logError } = options;

  // Log for debugging (but never log note contents!)
  logError?.(error);

  if (!(error instanceof CloakError)) {
    // Handle wallet-adapter or other errors
    const message = error instanceof Error ? error.message : String(error);
    
    if (message.includes("User rejected")) {
      showMessage("Transaction cancelled by user");
      return false;
    }
    
    showMessage("An unexpected error occurred. Please try again.");
    return false;
  }

  // Handle CloakError by category
  switch (error.category) {
    case "wallet":
      if (error.message.includes("not connected")) {
        showMessage("Please connect your wallet to continue");
      } else if (error.message.includes("insufficient")) {
        showMessage("Insufficient balance for this transaction");
      } else {
        showMessage("Wallet error: " + error.message);
      }
      return false;

    case "network":
      if (error.retryable && onRetry) {
        showMessage("Network issue detected. Retrying...");
        await delay(2000);
        await onRetry();
        return true;
      }
      showMessage("Network error. Please check your connection.");
      return false;

    case "prover":
      if (error.retryable && onRetry) {
        showMessage("Proof generation failed. Retrying...");
        await delay(1000);
        await onRetry();
        return true;
      }
      showMessage("Failed to generate proof. Please refresh and try again.");
      return false;

    case "relay":
      if (error.message.includes("nullifier")) {
        showMessage("This note has already been spent.");
        return false; // Don't retry - note is gone
      }
      if (error.retryable && onRetry) {
        showMessage("Relay service busy. Retrying...");
        await delay(3000);
        await onRetry();
        return true;
      }
      showMessage("Relay service error. Please try again later.");
      return false;

    case "validation":
      showMessage("Invalid input: " + error.message);
      return false;

    case "environment":
      showMessage("Configuration error: " + error.message);
      return false;

    default:
      showMessage("Error: " + error.message);
      return false;
  }
}

function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

### Usage example

```typescript
const performWithdraw = async () => {
  try {
    const result = await sdk.withdraw(connection, note, recipient);
    showSuccess("Withdrawal complete!");
    return result;
  } catch (error) {
    const retried = await handleCloakError(error, {
      showMessage: (msg) => toast.error(msg),
      logError: (err) => console.error("[Withdraw Error]", err),
      onRetry: () => performWithdraw(), // Recursive retry
    });
    
    if (!retried) {
      // Error was not retried or retry failed
      throw error;
    }
  }
};
```

## Deposit recovery

The SDK automatically computes Merkle proofs from on-chain state, so deposit recovery is handled seamlessly. If a deposit transaction succeeds but you lose the note metadata, you can reconstruct it:

```typescript
import { CloakSDK } from "@cloak.ag/sdk";

// If you saved the note before the deposit but lost the leafIndex
const savedNote = JSON.parse(localStorage.getItem("pending_note")!);
const signature = localStorage.getItem("pending_signature")!;

const sdk = new CloakSDK({ keypairBytes: keypair.secretKey, network: "devnet" });

// Verify the deposit transaction and get the leaf index from logs
const txDetails = await connection.getTransaction(signature, {
  commitment: "confirmed",
  maxSupportedTransactionVersion: 0,
});

if (txDetails?.meta?.logMessages) {
  // Parse the deposit event to get leaf index
  // The SDK handles this automatically during deposit
  console.log("Transaction confirmed at slot:", txDetails.slot);
}

// If you have the note with leafIndex, compute fresh proof from chain
if (savedNote.leafIndex !== undefined) {
  const proof = await sdk.getMerkleProof(connection, savedNote.leafIndex);
  savedNote.merkleProof = proof;
  savedNote.root = proof.root;
  
  // Save updated note
  localStorage.setItem(`note_${savedNote.commitment}`, JSON.stringify(savedNote));
}
```

<Tip>
Always use the `onNoteGenerated` callback to persist notes **before** the deposit transaction is sent. This prevents fund loss if the browser crashes.
</Tip>

## Retry strategies

### Exponential backoff

For retryable errors, use exponential backoff:

```typescript
async function withRetry<T>(
  operation: () => Promise<T>,
  maxAttempts: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;

      // Only retry if the error is retryable
      if (error instanceof CloakError && !error.retryable) {
        throw error;
      }

      if (attempt < maxAttempts - 1) {
        const delay = baseDelay * Math.pow(2, attempt);
        console.log(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);
        await new Promise((r) => setTimeout(r, delay));
      }
    }
  }

  throw lastError!;
}

// Usage
const result = await withRetry(
  () => sdk.withdraw(connection, note, recipient),
  3,    // max attempts
  2000  // base delay
);
```

### Circuit-breaker pattern

For production applications, implement a circuit breaker:

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailure: number = 0;
  private readonly threshold = 5;
  private readonly resetTimeout = 60000; // 1 minute

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    // Check if circuit is open
    if (this.isOpen()) {
      throw new Error("Circuit breaker is open. Please try again later.");
    }

    try {
      const result = await operation();
      this.reset();
      return result;
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }

  private isOpen(): boolean {
    if (this.failures >= this.threshold) {
      const timeSinceLastFailure = Date.now() - this.lastFailure;
      if (timeSinceLastFailure < this.resetTimeout) {
        return true;
      }
      // Reset after timeout
      this.reset();
    }
    return false;
  }

  private recordFailure(): void {
    this.failures++;
    this.lastFailure = Date.now();
  }

  private reset(): void {
    this.failures = 0;
  }
}

// Usage
const relayBreaker = new CircuitBreaker();

try {
  await relayBreaker.execute(() => 
    sdk.withdraw(connection, note, recipient)
  );
} catch (error) {
  if (error.message.includes("Circuit breaker")) {
    showMessage("Service temporarily unavailable. Please wait.");
  }
}
```

## Error logging best practices

<Warning>
**Never log note contents or secrets!** These contain spending keys.
</Warning>

```typescript
// ❌ DANGEROUS - Don't do this!
console.log("Failed with note:", note);
Sentry.captureException(error, { extra: { note } });

// ✅ Safe - Log only non-sensitive data
console.log("Failed for note commitment:", note.commitment.slice(0, 16) + "...");
Sentry.captureException(error, {
  extra: {
    noteCommitment: note.commitment,
    leafIndex: note.leafIndex,
    network: note.network,
    // Never include: sk_spend, r, or the full note object
  },
});
```

## Next steps

<CardGroup cols={2}>
<Card title="API reference" icon="code" href="/sdk/api-reference">
Complete SDK method and type documentation.
</Card>

<Card title="Core concepts" icon="lightbulb" href="/sdk/core-concepts">
Understand the cryptographic primitives.
</Card>
</CardGroup>

