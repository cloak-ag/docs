---
title: "Error handling"
description: "Handle errors gracefully and implement recovery strategies"
icon: "triangle-exclamation"
---

The Cloak SDK provides structured error handling with categorized errors, retry hints, and recovery utilities. This guide covers common error scenarios and how to handle them.

## CloakError

All SDK errors extend the `CloakError` class with useful metadata:

```typescript
class CloakError extends Error {
  category: ErrorCategory;
  retryable: boolean;
  originalError?: Error;
}

type ErrorCategory = 
  | "network"      // RPC or network failures
  | "prover"       // Proof generation failures
  | "relay"        // Relay service errors
  | "validation"   // Invalid inputs
  | "wallet"       // Wallet connection or signing issues
  | "environment"; // Missing dependencies or configuration
```

## Shield Pool error codes

The on-chain program uses hex error codes. The SDK provides `ShieldPoolErrors` to map these to user-friendly messages:

```typescript
import { ShieldPoolErrors } from "@cloak.ag/sdk";

// Check for specific error codes
const message = ShieldPoolErrors[0x1001]; // "Root not found in the roots ring"
```

### Error code reference

| Code | Name | Description |
|------|------|-------------|
| `0x1000` | InvalidRoot | Invalid Merkle root |
| `0x1001` | RootNotFound | Root not found in the roots ring (stale proof) |
| `0x1002` | RootsRingFull | Roots ring is full |
| `0x1010` | ProofInvalid | Zero-knowledge proof is invalid |
| `0x1011` | InvalidProofSize | Invalid proof size (expected 260 bytes) |
| `0x1012` | InvalidPublicInputs | Invalid public inputs |
| `0x1013` | VKeyMismatch | Verification key mismatch |
| `0x1020` | DoubleSpend | Note has already been spent |
| `0x1021` | NullifierShardFull | Nullifier shard is full (deprecated) |
| `0x1022` | InvalidNullifier | Invalid nullifier |
| `0x1023` | NullifierAlreadyUsed | Nullifier already used |
| `0x1030` | OutputsMismatch | Output addresses or amounts don't match proof |
| `0x1031` | Conservation | Amount conservation failed |
| `0x1032` | InvalidOutputsHash | Invalid outputs hash |
| `0x1033` | InvalidAmount | Invalid amount |
| `0x1034` | InvalidRecipient | Invalid recipient address |
| `0x1035` | CommitmentAlreadyExists | Commitment already in tree |
| `0x1050` | BadAccounts | Account validation failed |
| `0x1058` | InsufficientLamports | Insufficient lamports in pool |
| `0x1076` | ProofVerificationFailed | Groth16 proof verification failed |
| `0x1080` | MerkleTreeFull | Merkle tree is full |

### Common error handling

```typescript
import { ShieldPoolErrors, isRootNotFoundError } from "@cloak.ag/sdk";

try {
  await sdk.withdraw(connection, note, recipient);
} catch (error) {
  // Check for stale root (needs proof refresh)
  if (isRootNotFoundError(error)) {
    console.log("Merkle root expired, SDK will retry with fresh proof");
    // The SDK handles this internally with up to 3 retries
  }
  
  // Parse hex error code from transaction
  const match = error.message?.match(/0x([0-9a-f]{4})/i);
  if (match) {
    const code = parseInt(match[1], 16);
    const message = ShieldPoolErrors[code];
    console.log(`Program error: ${message || 'Unknown'} (0x${code.toString(16)})`);
  }
}
```

## Common issues and solutions

### 0x1001 RootNotFound on Devnet

**Problem**: Withdrawal fails with `custom program error: 0x1001` (RootNotFound).

**Cause**: The SDK defaults to mainnet's program ID. On devnet, this causes wrong Merkle tree PDAs to be derived.

**Solution**: Explicitly set the devnet program ID:

```typescript
import { PublicKey } from "@solana/web3.js";

const DEVNET_PROGRAM_ID = new PublicKey("3EvH6XYQir7D2RyzCdP7QFmJFfSPfdeoB8VnpLdEF4Kr");

const sdk = new CloakSDK({
  keypairBytes: keypair.secretKey,
  network: "devnet",
  programId: DEVNET_PROGRAM_ID,  // This is required!
});
```

### "max loaded accounts data size cap" error

**Problem**: Deposit fails with account data size exceeded error on devnet.

**Cause**: Public devnet RPC has stricter limits than mainnet.

**Solution**: Use a dedicated RPC (like Helius) or set `loadedAccountsDataSizeLimit`:

```typescript
await sdk.deposit(connection, amount, {
  loadedAccountsDataSizeLimit: 512 * 1024, // 512KB
});
```

### Stale Merkle root after many deposits

**Problem**: Withdrawal fails with 0x1001 after waiting too long.

**Cause**: The on-chain roots ring only stores the last 100 roots. If >100 deposits happen between your deposit and withdrawal, your proof's root expires.

**Solution**: The SDK automatically retries with fresh proofs (up to 3 times). If it still fails, re-deposit.

## Handling errors by category

### Network errors

Network errors are usually transient and retryable:

```typescript
import { CloakError } from "@cloak.ag/sdk";

try {
  await sdk.deposit(connection, amount);
} catch (error) {
  if (error instanceof CloakError && error.category === "network") {
    if (error.retryable) {
      console.log("Network error, retrying in 2 seconds...");
      await delay(2000);
      // Retry the operation
    } else {
      console.error("Network configuration error:", error.message);
    }
  }
}
```

<AccordionGroup>
<Accordion title="Common network errors">

| Error | Cause | Solution |
|-------|-------|----------|
| `timeout` | RPC unresponsive | Retry with backoff, or switch RPC |
| `rate limited` | Too many requests | Implement exponential backoff |
| `connection refused` | RPC down | Switch to backup RPC |

</Accordion>
</AccordionGroup>

### Wallet errors

Wallet errors occur when signing is rejected or the wallet disconnects:

```typescript
try {
  await sdk.deposit(connection, amount);
} catch (error) {
  if (error instanceof CloakError && error.category === "wallet") {
    if (error.message.includes("not connected")) {
      showMessage("Please connect your wallet");
      openWalletModal();
    } else if (error.message.includes("rejected")) {
      showMessage("Transaction cancelled");
    } else if (error.message.includes("insufficient")) {
      showMessage("Insufficient SOL balance");
    }
  }
}
```

### Prover errors

Proof generation can fail due to circuit issues or resource constraints:

```typescript
try {
  await sdk.withdraw(connection, note, recipient);
} catch (error) {
  if (error instanceof CloakError && error.category === "prover") {
    if (error.message.includes("Circuit")) {
      showMessage("Failed to load proof circuits. Please refresh.");
    } else if (error.retryable) {
      showMessage("Proof generation failed. Retrying...");
      // Retry once
    } else {
      showMessage("Unable to generate proof. Please try again later.");
    }
  }
}
```

<Tip>
Proof generation is computationally intensive. On slower devices, consider showing a loading indicator with an estimated time.
</Tip>

### Relay errors

Relay errors occur when submitting withdrawals:

```typescript
import { CloakError, RootNotFoundError, isRootNotFoundError } from "@cloak.ag/sdk";

try {
  await sdk.withdraw(connection, note, recipient);
} catch (error) {
  // Special handling for stale Merkle root errors
  if (error instanceof RootNotFoundError || isRootNotFoundError(error)) {
    // The SDK handles this internally with retries (up to 3),
    // but you might see it after max retries during high activity
    showMessage("Merkle tree updated rapidly. Please try again.");
    return;
  }
  
  if (error instanceof CloakError && error.category === "relay") {
    if (error.message.includes("nullifier")) {
      showMessage("This note has already been spent.");
      removeNoteFromStorage(note);
    } else if (error.retryable) {
      showMessage("Relay temporarily unavailable. Retrying...");
    }
  }
}
```

<Note>
**RootNotFoundError** occurs when the Merkle root used in your proof is no longer in the on-chain root history. This happens during high deposit activity when >100 deposits occur between proof generation and transaction submission. The SDK automatically retries with a fresh root up to 3 times.
</Note>

### Validation errors

Validation errors indicate incorrect inputs:

```typescript
try {
  await sdk.send(connection, note, recipients);
} catch (error) {
  if (error instanceof CloakError && error.category === "validation") {
    if (error.message.includes("sum")) {
      showMessage("Recipient amounts don't match note balance");
    } else if (error.message.includes("deposited")) {
      showMessage("Note must be deposited before withdrawal");
    } else if (error.message.includes("address")) {
      showMessage("Invalid recipient address");
    }
  }
}
```

### On-chain errors

The SDK computes Merkle proofs directly from on-chain state. These errors may occur when reading chain data:

```typescript
try {
  await sdk.withdraw(connection, note, recipient);
} catch (error) {
  if (error instanceof CloakError && error.category === "network") {
    if (error.message.includes("Merkle tree")) {
      showMessage("Failed to read on-chain state. Please try again.");
    } else if (error.retryable) {
      showMessage("Network issue. Retrying...");
    }
  }
}
```

<Tip>
The SDK computes Merkle proofs directly from on-chain state, making it more reliable than external indexer services.
</Tip>

## Comprehensive error handler

Here's a reusable error handler for all SDK operations:

```typescript utils/handleCloakError.ts
import { CloakError } from "@cloak.ag/sdk";

interface ErrorHandlerOptions {
  onRetry?: () => Promise<void>;
  showMessage: (message: string) => void;
  logError?: (error: unknown) => void;
}

export async function handleCloakError(
  error: unknown,
  options: ErrorHandlerOptions
): Promise<boolean> {
  const { onRetry, showMessage, logError } = options;

  // Log for debugging (but never log note contents!)
  logError?.(error);

  if (!(error instanceof CloakError)) {
    // Handle wallet-adapter or other errors
    const message = error instanceof Error ? error.message : String(error);
    
    if (message.includes("User rejected")) {
      showMessage("Transaction cancelled by user");
      return false;
    }
    
    showMessage("An unexpected error occurred. Please try again.");
    return false;
  }

  // Handle CloakError by category
  switch (error.category) {
    case "wallet":
      if (error.message.includes("not connected")) {
        showMessage("Please connect your wallet to continue");
      } else if (error.message.includes("insufficient")) {
        showMessage("Insufficient balance for this transaction");
      } else {
        showMessage("Wallet error: " + error.message);
      }
      return false;

    case "network":
      if (error.retryable && onRetry) {
        showMessage("Network issue detected. Retrying...");
        await delay(2000);
        await onRetry();
        return true;
      }
      showMessage("Network error. Please check your connection.");
      return false;

    case "prover":
      if (error.retryable && onRetry) {
        showMessage("Proof generation failed. Retrying...");
        await delay(1000);
        await onRetry();
        return true;
      }
      showMessage("Failed to generate proof. Please refresh and try again.");
      return false;

    case "relay":
      if (error.message.includes("nullifier")) {
        showMessage("This note has already been spent.");
        return false; // Don't retry - note is gone
      }
      if (error.retryable && onRetry) {
        showMessage("Relay service busy. Retrying...");
        await delay(3000);
        await onRetry();
        return true;
      }
      showMessage("Relay service error. Please try again later.");
      return false;

    case "validation":
      showMessage("Invalid input: " + error.message);
      return false;

    case "environment":
      showMessage("Configuration error: " + error.message);
      return false;

    default:
      showMessage("Error: " + error.message);
      return false;
  }
}

function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

### Usage example

```typescript
const performWithdraw = async () => {
  try {
    const result = await sdk.withdraw(connection, note, recipient);
    showSuccess("Withdrawal complete!");
    return result;
  } catch (error) {
    const retried = await handleCloakError(error, {
      showMessage: (msg) => toast.error(msg),
      logError: (err) => console.error("[Withdraw Error]", err),
      onRetry: () => performWithdraw(), // Recursive retry
    });
    
    if (!retried) {
      // Error was not retried or retry failed
      throw error;
    }
  }
};
```

## Deposit recovery

If a deposit transaction succeeds but the browser crashes before you save the note data, you can recover using the transaction signature:

```typescript
import { Connection, PublicKey } from "@solana/web3.js";
import { computeProofFromChain, getShieldPoolPDAs, CLOAK_PROGRAM_ID } from "@cloak.ag/sdk";

// You saved the note before the crash (via onNoteGenerated callback)
const savedNote = JSON.parse(localStorage.getItem("pending_note")!);
const signature = localStorage.getItem("pending_signature")!;

// Verify the transaction on-chain
const connection = new Connection("https://api.devnet.solana.com");
const txDetails = await connection.getTransaction(signature, {
  commitment: "confirmed",
  maxSupportedTransactionVersion: 0,
});

if (txDetails && !txDetails.meta?.err) {
  // Transaction succeeded - compute the Merkle proof from on-chain state
  const { merkleTree } = getShieldPoolPDAs(CLOAK_PROGRAM_ID);
  
  // If you know the leaf index from transaction logs
  const proof = await computeProofFromChain(connection, merkleTree, leafIndex);
  
  // Update the note with recovered data
  savedNote.depositSignature = signature;
  savedNote.leafIndex = leafIndex;
  savedNote.root = proof.root;
  savedNote.merkleProof = {
    pathElements: proof.pathElements,
    pathIndices: proof.pathIndices,
  };
  
  // Save updated note
  localStorage.setItem(`note_${savedNote.commitment}`, JSON.stringify(savedNote));
  localStorage.removeItem("pending_note");
}
```

<Tip>
The SDK automatically computes and stores Merkle proofs during deposit. The `onNoteGenerated` callback fires **before** the deposit transaction is sent, ensuring your note is safely persisted even if the browser crashes.
</Tip>

## Retry strategies

### Exponential backoff

For retryable errors, use exponential backoff:

```typescript
async function withRetry<T>(
  operation: () => Promise<T>,
  maxAttempts: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;

      // Only retry if the error is retryable
      if (error instanceof CloakError && !error.retryable) {
        throw error;
      }

      if (attempt < maxAttempts - 1) {
        const delay = baseDelay * Math.pow(2, attempt);
        console.log(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);
        await new Promise((r) => setTimeout(r, delay));
      }
    }
  }

  throw lastError!;
}

// Usage
const result = await withRetry(
  () => sdk.withdraw(connection, note, recipient),
  3,    // max attempts
  2000  // base delay
);
```

### Circuit-breaker pattern

For production applications, implement a circuit breaker:

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailure: number = 0;
  private readonly threshold = 5;
  private readonly resetTimeout = 60000; // 1 minute

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    // Check if circuit is open
    if (this.isOpen()) {
      throw new Error("Circuit breaker is open. Please try again later.");
    }

    try {
      const result = await operation();
      this.reset();
      return result;
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }

  private isOpen(): boolean {
    if (this.failures >= this.threshold) {
      const timeSinceLastFailure = Date.now() - this.lastFailure;
      if (timeSinceLastFailure < this.resetTimeout) {
        return true;
      }
      // Reset after timeout
      this.reset();
    }
    return false;
  }

  private recordFailure(): void {
    this.failures++;
    this.lastFailure = Date.now();
  }

  private reset(): void {
    this.failures = 0;
  }
}

// Usage
const relayBreaker = new CircuitBreaker();

try {
  await relayBreaker.execute(() => 
    sdk.withdraw(connection, note, recipient)
  );
} catch (error) {
  if (error.message.includes("Circuit breaker")) {
    showMessage("Service temporarily unavailable. Please wait.");
  }
}
```

## On-chain program error codes

The SDK exports `ShieldPoolErrors` - a complete mapping of on-chain program error codes to user-friendly messages. Use these for detailed error handling:

```typescript
import { ShieldPoolErrors, parseError } from "@cloak.ag/sdk";
```

<AccordionGroup>
<Accordion title="Root management errors (0x1000-0x1002)">

| Code | Message |
|------|---------|
| `0x1000` | Invalid Merkle root |
| `0x1001` | Root not found in the roots ring |
| `0x1002` | Roots ring is full |

</Accordion>

<Accordion title="Proof verification errors (0x1010-0x1016)">

| Code | Message |
|------|---------|
| `0x1010` | Zero-knowledge proof is invalid |
| `0x1011` | Invalid proof size (expected 260 bytes) |
| `0x1012` | Invalid public inputs |
| `0x1013` | Verification key mismatch |

</Accordion>

<Accordion title="Nullifier errors (0x1020-0x1022)">

| Code | Message |
|------|---------|
| `0x1020` | Double spend detected - this note has already been spent |
| `0x1021` | Nullifier shard is full |
| `0x1022` | Invalid nullifier |

</Accordion>

<Accordion title="Transaction validation errors (0x1030-0x1036)">

| Code | Message |
|------|---------|
| `0x1030` | Output addresses or amounts don't match the proof |
| `0x1031` | Amount conservation failed - outputs + fee must equal input amount |
| `0x1032` | Invalid outputs hash |
| `0x1033` | Invalid amount (must be greater than zero) |
| `0x1034` | Invalid recipient address |
| `0x1035` | Commitment already exists in the tree |
| `0x1036` | Commitment log is full |

</Accordion>

<Accordion title="Account errors (0x1050-0x105c)">

| Code | Message |
|------|---------|
| `0x1050` | Account validation failed |
| `0x1051` | Pool account owner mismatch |
| `0x1052` | Treasury account owner mismatch |
| `0x1058` | Insufficient lamports in pool or account |
| `0x105c` | Invalid admin authority |

</Accordion>

<Accordion title="Groth16 verifier errors (0x1070-0x1076)">

| Code | Message |
|------|---------|
| `0x1070` | Invalid G1 point length |
| `0x1071` | Invalid G2 point length |
| `0x1072` | Invalid public inputs length |
| `0x1073` | Public input exceeds field size |
| `0x1076` | Proof verification failed |

</Accordion>
</AccordionGroup>

### Using parseError for user-friendly messages

The SDK provides `parseError()` which returns a structured error object with user-friendly messages:

```typescript
import { parseError, type UserFriendlyError } from "@cloak.ag/sdk";

try {
  await sdk.withdraw(connection, note, recipient);
} catch (error) {
  const parsed: UserFriendlyError = parseError(error);
  
  console.log(parsed.title);      // "Transaction Failed"
  console.log(parsed.message);    // "Double spend detected - this note has already been spent"
  console.log(parsed.category);   // "transaction"
  console.log(parsed.suggestion); // Optional suggestion for the user
  console.log(parsed.recoverable); // false (can't retry double-spend)
  
  showToast({
    title: parsed.title,
    message: parsed.message,
    action: parsed.suggestion,
  });
}
```

### Error categories (UserFriendlyError)

| Category | Description | Recoverable |
|----------|-------------|-------------|
| `wallet` | Wallet connection, signing, or balance issues | Usually yes |
| `network` | RPC or network connectivity problems | Yes |
| `validation` | Invalid inputs or parameters | No (fix input) |
| `service` | Relay or proof service issues | Yes |
| `transaction` | On-chain transaction failures | Depends |
| `unknown` | Unexpected errors | Maybe |

## Error logging best practices

<Warning>
**Never log note contents or secrets!** These contain spending keys.
</Warning>

```typescript
// ❌ DANGEROUS - Don't do this!
console.log("Failed with note:", note);
Sentry.captureException(error, { extra: { note } });

// ✅ Safe - Log only non-sensitive data
console.log("Failed for note commitment:", note.commitment.slice(0, 16) + "...");
Sentry.captureException(error, {
  extra: {
    noteCommitment: note.commitment,
    leafIndex: note.leafIndex,
    network: note.network,
    // Never include: sk_spend, r, or the full note object
  },
});
```

## Next steps

<CardGroup cols={2}>
<Card title="API reference" icon="code" href="/sdk/api-reference">
Complete SDK method and type documentation.
</Card>

<Card title="Core concepts" icon="lightbulb" href="/sdk/core-concepts">
Understand the cryptographic primitives.
</Card>
</CardGroup>

